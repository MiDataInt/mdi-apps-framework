
#----------------------------------------------------------------------
# reactive components that provide test code execution in an environment
# that has access to analyzed data sets but is entirely free-coded
#----------------------------------------------------------------------
# must never be enabled in server mode, as it allows arbitrary code execution 
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# BEGIN MODULE SERVER
#----------------------------------------------------------------------
sandboxServer <- function(id, parentId, options) {
    moduleServer(id, function(input, output, session) {
        ns <- NS(id) # in case we create inputs, e.g. via renderUI
        parentNs <- NS(parentId)
        module <- 'sandbox' # for reportProgress tracing
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# setup module with common results access elements
#----------------------------------------------------------------------
analzyeName <- appStepNamesByType$analyze
isAnalyzePragma <- !is.null(analzyeName)
schema <- if(isAnalyzePragma) selectAnalysesServer(
    id = 'schema',
    parentId = id,
    parentOptions = options
) else NULL
codeEditorId <- paste(parentNs(id), "code-editor", sep="-")
codeEditorContentsId <- paste("code-editor", "contents", sep="-")

#----------------------------------------------------------------------
# execute code in response to user button click ...
#----------------------------------------------------------------------
session$sendCustomMessage("initializeAceCodeEditor", codeEditorId)
observeEvent(input$codeButton,  { executeCode('code') })
observeEvent(input$plotButton,  { executeCode('plot') })
observeEvent(input$plotlyButton,{ executeCode('plotly') })
observeEvent(input$tableButton, { executeCode('table') })
codeExecutionMode <- NULL
executeCode <- function(mode){
    reportProgress(paste(mode, 'button'), module)
    codeExecutionMode <<- mode
    session$sendCustomMessage("getAceCodeContents", codeEditorId)
}

observeEvent(input[[codeEditorContentsId]], {
    reportProgress('input[[codeEditorContentsId]]')
    expr <- tryCatch({
        parse(text=input[[codeEditorContentsId]])
    }, error=function(e){
        safeError(e)
    })
         if(codeExecutionMode == 'code')   codeExpr(expr)
    else if(codeExecutionMode == 'plot')   plotExpr(expr)
    else if(codeExecutionMode == 'plotly') plotlyExpr(expr)
    else if(codeExecutionMode == 'table')  tableExpr(expr)      
})

#----------------------------------------------------------------------
# execute useful preformatted code actions in response to link click ...
#----------------------------------------------------------------------
# list objects in the session environment
observeEvent(input$ls_sessionEnv, {
    codeExpr({
        out <- list()
        for(objectName in ls(sessionEnv)){
            x <- class(get(objectName, envir=sessionEnv))[1]
            out[[x]] <- if(is.null(out[[x]])) objectName
                        else c(out[[x]], objectName)
        }
        out
    })
})

# show the structure of the output of the selected analysis job, if any
job <- reactive({
    selected <- schema$selected() # numeric index
    req(selected)
    x <- schema$list[[selected]] # only act on successful analyses
    id <- names(schema$list)[selected]
    analysisType <- getAnalysisType(x$Analysis_Type) 
    job <- structure(
        list(
            schema     = x,
            schemaId   = id
        ),
        class = x$Analysis_Type
    )
    loadJobOutput(job)
})
if(isAnalyzePragma) observeEvent(input$str_job, {
    job <- job()
    req(job)
    codeExpr(capture.output(str( job )))
})

#----------------------------------------------------------------------
# ... to generate one of several types of user-intended output
#----------------------------------------------------------------------

# the output of the code (not including the plot or table)
codeExpr <- reactiveVal(NULL)
output$codeOutput <- renderUI({
    req(codeExpr())
    tags$pre(
        style="max-height: 400px; overflow: auto;",
        tryCatch({
            paste(collapse="\n", capture.output(eval(codeExpr())))
        }, warning=function(warning){
            paste(collapse="\n", warning)
        }, error=function(error){
            paste(collapse="\n", error)
        }) 
    )    
})

# a static plot generated by the code
plotExpr <- reactiveVal(NULL)
output$plotOutput  <- renderPlot({
    eval(plotExpr())
})

# an interactive plot generated by the code
plotlyExpr <- reactiveVal(NULL)
output$plotlyOutput  <- renderPlotly({
    eval(plotlyExpr())
    #plot_ly(data = iris, x = ~Sepal.Length, y = ~Petal.Length)
})

# a DT table of a data frame or matrix generated by the code
tableExpr <- reactiveVal(NULL)
output$tableOutput <- renderDT(
    eval(tableExpr()),
    options = list(
        lengthMenu = c(20,100,500),
        pageLength = 10
    ),
    class = "display table-compact-4",
    escape = FALSE, 
    selection = 'single', 
    editable = FALSE, 
    rownames = TRUE # must be true for editing to work, not sure why (datatables peculiarity)
)

##----------------------------------------------------------------------
## define bookmarking actions
##----------------------------------------------------------------------
#observe({
#    bm <- getModuleBookmark(id, module, bookmark, locks)
#    req(bm)
#    data$list  <- bm$schema
#    data$selected <- bm$selected 
#})

#----------------------------------------------------------------------
# set return value
#----------------------------------------------------------------------
NULL

#----------------------------------------------------------------------
# END MODULE SERVER
#----------------------------------------------------------------------
})}
#----------------------------------------------------------------------

