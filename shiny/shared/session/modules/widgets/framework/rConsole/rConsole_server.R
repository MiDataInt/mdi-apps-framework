#----------------------------------------------------------------------
# reactive components for populating an R Console dialog
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# BEGIN MODULE SERVER
#----------------------------------------------------------------------
rConsoleServer <- function( # generally, you do not call rConsoleServer directly
    id,
    envir,        # the environment in which R code is evaluated
    code = NULL,  # R code to pre-populate into the editor 
    tall = FALSE, # whether the dialog is currently extra-large (xl)
    wide = FALSE,
    onExit = NULL    
) {
    moduleServer(id, function(input, output, session) {
#----------------------------------------------------------------------
if(serverEnv$IS_SERVER) return(NULL)
user <- headerStatusData$userDisplayName
req(user)

#----------------------------------------------------------------------
# initialize the terminal
#----------------------------------------------------------------------
module <- "rConsole"
spinnerSelector <- "#rConsoleSpinner"
observers <- list() # for module self-destruction
codeEditorId <- session$ns("codeEditor")
codeEditorContentsId <- paste("codeEditor", "contents", sep = "-")
selfDestruct <- observe({
    session$sendCustomMessage("initializeAceCodeEditor", codeEditorId)
    if(!is.null(code)) session$sendCustomMessage("setAceCodeContents", list(
        editorId = codeEditorId,
        code = code
    ))
    toggleSize()
    selfDestruct$destroy()
})

#----------------------------------------------------------------------
# execute free code in response to user button click ...
#----------------------------------------------------------------------
observers$codeButton   <- observeEvent(input$codeButton,   { executeCode('output') })
observers$plotButton   <- observeEvent(input$plotButton,   { executeCode('plot') })
observers$plotlyButton <- observeEvent(input$plotlyButton, { executeCode('plotly') })
observers$tableButton  <- observeEvent(input$tableButton,  { executeCode('table') })
target <- NULL
userCode <- reactiveVal("")
reactives <- list(
    output = reactiveVal(NULL),
    plot   = reactiveVal(NULL),
    plotly = reactiveVal(NULL),
    table  = reactiveVal(NULL)
)
executeCode <- function(mode){
    target <<- mode
    session$sendCustomMessage("getAceCodeContents", list(editorId = codeEditorId))
}
fillReactive <- function(id, expr){
    reactives[[id]](NULL)
    hide(selector = ".r-console-pane")
    show(id)        
    reactives[[id]](expr)
}
observers$codeEditorContentsId <- observeEvent(input[[codeEditorContentsId]], {
    code <- input[[codeEditorContentsId]]$code
    userCode(code)
    expr <- tryCatch({ # turn user code text into an R expression
        parse(text = code)
    }, error = function(e){
        safeError(e)
    })
    fillReactive(target, expr)
})

#----------------------------------------------------------------------
# execute useful preformatted code actions in response to link click ...
#----------------------------------------------------------------------
# list objects in the session environment
observeEvent(input$ls_sessionEnv, {
    fillReactive("output", {
        out <- list()
        for(objectName in ls(sessionEnv)){
            x <- class(get(objectName, envir = sessionEnv))[1]
            out[[x]] <- if(is.null(out[[x]])) objectName
                        else c(out[[x]], objectName)
        }
        out
    })
})

#----------------------------------------------------------------------
# ... to generate one of several types of user-intended output
#----------------------------------------------------------------------
evalExpr <- function(target){
    show(selector = spinnerSelector)
    tryCatch({
        x <- eval(reactives[[target]](), envir)
        hide(selector = spinnerSelector)
        x
    }, warning = function(warning){
        hide(selector = spinnerSelector)
        paste(collapse = "\n", warning)
    }, error = function(error){
        hide(selector = spinnerSelector)
        paste(collapse = "\n", error)
    }) 
}

# the text output of the code (not including the plot or table)
maxHeight <- reactiveVal(if(tall) "650px" else "500px")
output$codeOutput <- renderUI({
    tags$pre(
        style = paste("max-height: ", maxHeight(), "; overflow: auto;"),
        paste(collapse = "\n", capture.output(evalExpr("output")))
    )    
})

# a static plot generated by the code
output$plotOutput  <- renderPlot({
    evalExpr("plot")
})

# an interactive plot generated by the code
output$plotlyOutput  <- renderPlotly({
    evalExpr("plotly")
    # plot_ly(data = iris, x = ~Sepal.Length, y = ~Petal.Length)
})

# a DT table of a data frame or matrix generated by the code
output$tableOutput <- renderDT(
    evalExpr("table"),
    options = list(
        lengthMenu = c(20, 100, 500),
        pageLength = 10
    ),
    class = "display table-compact-4",
    escape = FALSE, 
    selection = 'single', 
    editable = FALSE, 
    rownames = TRUE # must be true for editing to work, not sure why (datatables peculiarity)
)

#----------------------------------------------------------------------
# toggle the terminal dimensions
#----------------------------------------------------------------------
toggleSize <- function(){
    toggleClass(selector = ".modal-dialog", class = "modal-xl", condition = wide)
    toggleClass(selector = ".r-console-lg", class = "r-console-xl", condition = tall)
    toggleClass(selector = ".r-console-editor-lg", class = "r-console-editor-xl", condition = tall)
}
observers$toggleWidth <- observeEvent(input$toggleWidth, { 
    wide <<- !wide
    toggleSize()
})
observers$toggleHeight <- observeEvent(input$toggleHeight, { 
    tall <<- !tall    
    maxHeight(if(tall) "650px" else "500px")
    toggleSize()
})

#----------------------------------------------------------------------
# return value
#----------------------------------------------------------------------
list(
    observers = observers, # for use by destroyModuleObservers
    onDestroy = function(){
        list( # return the module's cached state object
            code = userCode(),
            tall = tall,
            wide = wide
        )
    }
)

#----------------------------------------------------------------------
# END MODULE SERVER
#----------------------------------------------------------------------
})}
#----------------------------------------------------------------------
