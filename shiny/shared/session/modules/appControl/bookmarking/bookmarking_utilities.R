#----------------------------------------------------------------------
# bookmarking support functions
#----------------------------------------------------------------------

# allow developers to tag the inputs whose values should be recovered from a bookmark
# no other inputs are reset
# usage: in code, replace  xxxInput(id,label) with bookmarkInput('xxxInput',id,label)
bookmarkedInputs <- list()
bookmarkInput <- function(type, id, ...){
    bookmarkedInputs[[id]] <<- type    
    get(type)(id, ...)
}

# create a bookmark for the current state of the app as serialized json
getBookmarkJson <- function(){
    reportProgress('getBookmarkJson')

    if(is.null(app$NAME) || app$NAME == CONSTANTS$apps$launchPage) return(NULL) # only bookmark from within apps
    bookmark <- list(
        app = app$NAME,
        versions = list(
            app = list(
                name    = gitStatusData$app$name,
                version = if(gitStatusData$app$version == "na") NA else gitStatusData$app$version
            ),
            suite = list(
                name = gitStatusData$suite$name,
                head = gitStatusData$suite$head
            ),
            framework = list(
                name = gitFrameworkStatus$name,
                head = gitFrameworkStatus$head
            )
        ),
        input = list(),        
        settings = list(),
        outcomes = list(),
        locks = list(),
        step  = input$sidebarMenu       
    )
    for(stepName in names(app$config$appSteps)){ # convert reactives to hard values
        stepData <- app[[stepName]]
        if(typeof(stepData) != 'list') next()
        
        # collect the canonical bookmarked module return values: input, settings and outcomes
        if(!is.null(stepData$input))    
            bookmark$input[[stepName]] <- reactiveValuesToList(stepData$input) # always reactiveValues
        if(!is.null(stepData$settings)) 
            bookmark$settings[[stepName]] <- stepData$settings() # always a reactive or reactiveVal
        parseOutcomes <- function(x){  
            if(is.reactivevalues(x)) reactiveValuesToList(x)
            else if(is.reactive(x)) x() # handles reactive or reactiveVal
            else if(is.list(x)) lapply(x, parseOutcomes) # otherwise, outcomes must be a list of reactives
            else NULL
        }
        if(!is.null(stepData$outcomes)) bookmark$outcomes[[stepName]] <- parseOutcomes(stepData$outcomes)
        
        # remember record locking
        bookmark$locks[[stepName]] <- reactiveValuesToList(locks[[stepName]])
    }
    serializeJSON(bookmark) # bookmarks stored as a JSON document    
}

# extract the app that owns a bookmark
getTargetAppFromBookmark <- function(serializedJson){
    unserializeJSON(serializedJson)[c('app', 'step')]
}
getTargetAppFromBookmarkFile <- function(file, sendFeedback){
    tryCatch({
        serializedJson <- loadResourceText(file) # from the file upload widget
        getTargetAppFromBookmark(serializedJson)
    }, error = function(e){
        sendFeedback('invalid bookmark file: could not extract target app', isError = TRUE)
        NULL
    })
}

# helper function to load a bookmark from the bookmark history
# takes an incoming bookmark that is a json text string generated by getBookmarkJson
loadBookmarkFromString <- function(bookmark){
    path <- tempfile(pattern = "bookmark", fileext = ".mdi")
    cat(bookmark, file = path)
    loadIncomingFile(
        list(
            name = 'bookmark.mdi',
            datapath = path,
            nocache = TRUE # don't continue recaching, we've already got this one
        ),
        allowedFileTypes = CONSTANTS$sourceFileTypes$bookmark,
        sendFeedback = function(...) NULL,
        isLaunchPage = TRUE,
        incomingFile = NULL
    )    
}

# helper function for step modules to react to bookmark
getModuleBookmark <- function(stepName, module, bookmark, locks){
    req(bookmark$step)
    reportProgress('load bookmark', module)
    if(bookmark$step == stepName) stopSpinner(session)
    isolate({
        # clear any current locks for this step
        for(x in names(locks[[stepName]])) locks[[stepName]][[x]] <- NULL
        # set the prior locks
        for(x in names(bookmark$locks[[stepName]])) {
            locks[[stepName]][[x]] <- bookmark$locks[[stepName]][[x]]
        }
        # return the bookmark values
        list(
            input    = bookmark$input[[stepName]], # can be null
            settings = bookmark$settings[[stepName]],
            outcomes = bookmark$outcomes[[stepName]]
        )     
    })
}

# helper function to playback the exact state of only the previously visible step pane
# that tabbed pane will be the one restored into view on bookmark load
playbackStepBookmark <- function(stepName, module, session, bookmark, handlers=list()){
    req(bookmark$step)
    reportProgress('playbackStepBookmark', module)
    isolate({    
        prefix <- paste0(stepName, '-')    
        bmInputs <- startsWith(names(bookmarkedInputs), prefix)
        bmInputs <- names(bookmarkedInputs[bmInputs])    
        inputCache <- bookmark$input[[stepName]]
        inputCacheNames <- names(inputCache)        
        inputNames <- names(session$input)
        for(bmInput in bmInputs){
            id <- sub(prefix, '', bmInput)
            isOK <- id %in% inputCacheNames && id %in% inputNames
            if(!isOK) next
            if(is.null(handlers[[id]])) switch( # regular inputs we simply fill as per normal
                bookmarkedInputs[[bmInput]],
                textInput = updateTextInput(session, id, value = inputCache[[id]]),
                selectInput = updateSelectInput(session, id, selected = inputCache[[id]])
            ) else {
                reportProgress(id, 'handling')
                handlers[[id]](id, inputCache[[id]]) # cascading inputs that require custom handlers
            }
        }
    })
}
