#----------------------------------------------------------------------
# reactive components for creating a cached, ordered list of historical items
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# BEGIN MODULE SERVER
#----------------------------------------------------------------------
historyListServer <- function(id, parentId, namespace, dataTable, maxN,
                              action, actionFn, uniqueByContents=TRUE, uniqueFn=NULL) {
    moduleServer(id, function(input, output, session) {
        ns <- NS(id)
        parentNs <- function(x) paste(parentId, ns(x), sep = "-")
        module <- ns('historyList') # for reportProgress tracing

#----------------------------------------------------------------------
# initialize the widget
#----------------------------------------------------------------------

# add fixed, standardized columns to the template table 
displayCols <- c('Action', names(dataTable), 'Saved_On')
dataTable[, ':='(
    Saved_On = character(),
    key      = character(), # digest generated by us
    hash     = character(), # digest generated by storr
    index    = integer()    # generated by us to establish an item key
)]

# initialize the history item action
actionId <- "doAction"

# function for parsing item keys
getItemKey <- function(i) paste(userKey(), 'item', i, sep = '__')
indices <- 1:maxN

#----------------------------------------------------------------------
# user data reactives
#----------------------------------------------------------------------

# set the key that identifies the user
userKey <- reactive({
    if(headerStatusData$userDisplayName != "") headerStatusData$userDisplayName # prefer email or host user name
    else if(!serverEnv$REQUIRES_AUTHENTICATION) cookie$hostKey # fallback in case failed to get host user name
    else NULL # if not logged in server mode
})

# get or create the master table of all history items
table <- reactiveVal(NULL)
observeEvent(userKey(), {
    userKey <- userKey()
    if(is.null(userKey)) return(table(NULL)) # can't track history for anonymous user on a public server
    if(!serverEnv$STORR$exists(userKey, namespace)) serverEnv$STORR$set(userKey, dataTable, namespace = namespace)
    table( serverEnv$STORR$get(userKey, namespace) )
})    
        
#----------------------------------------------------------------------
# generate the history table
#----------------------------------------------------------------------
output$table <- renderDT(
    {
        dt <- table()
        req(dt)
        dt <- dt[TRUE] # force a copy prior to Action modification
        dt[, Action := tableActionLinks(parentNs(actionId), nrow(dt), action)]
        dt[, .SD, .SDcols = displayCols]
    },
    class = "display table-compact-4",
    escape = FALSE, 
    selection = 'none', 
    editable = FALSE, 
    rownames = FALSE 
)

#----------------------------------------------------------------------
# respond to an action button click
#----------------------------------------------------------------------
observeEvent(input[[actionId]], {
    row <- getTableActionLinkRow(input, actionId)
    x <- get(index = table()[row, index])
    actionFn(x)
})

#----------------------------------------------------------------------
# add a new item to the history list, purging prior entries as instructed
#----------------------------------------------------------------------
set <- function(item, data){
    dt <- table()
    req(dt)
    item$Saved_On <- as.character(Sys.time()) # add values for standard, fixed columns
    item$key <- digest(data)
    item$hash <- ""
    item$index <- 1e9
    h <- rbind(item, dt)[order(-Saved_On)] # add the new item and reverse sort by date
    if(uniqueByContents) h <- unique(h, by = 'key') # enforce uniqueness by purging duplicates for all requested keyBys
    if(!is.null(uniqueFn)) h <- uniqueFn(h)       # the oldest records are the ones that are deleted
    if(nrow(h) > maxN) h <- h[1:maxN] # enforce a storage limit
    i <- min(indices[indices %notin% h[, index]]) # fill the numeric slot index for the new item
    h[1, index := i]
    h[1, hash := serverEnv$STORR$set(getItemKey(i), data, namespace = namespace)] # store the item itself
    serverEnv$STORR$set(userKey(), h, namespace = namespace) # and record the new item in the history table
    table(h)   
}

#----------------------------------------------------------------------
# get a new item from the history list by index or hash
#----------------------------------------------------------------------
get <- function(index=NULL, hash=NULL){
    req(userKey())    
    if(!is.null(index)) serverEnv$STORR$get(getItemKey(index), namespace)
    else if(!is.null(hash)) serverEnv$STORR$get_value(hash)
    else NULL
}

#----------------------------------------------------------------------
# return the history table and associated methods
#----------------------------------------------------------------------
list(
    table = table,
    set   = set,
    get   = get
)

#----------------------------------------------------------------------
# END MODULE SERVER
#----------------------------------------------------------------------
})}
#----------------------------------------------------------------------
